#!/usr/bin/env node

var EOL = require('os').EOL;
var DNL = EOL + EOL;
var fs = require('fs');
var path = require('path');
var util = require('util');
var base = path.normalize(path.join(__dirname, '..'));
var qt = require('../test/fixtures/qt');
var config = require('../test/util/config');
var pkg = require('../package.json');
var output = process.argv[2] || path.join(base, 'doc', 'cheatsheet.md');
var heading = util.format('# %s(1) cheatsheet', pkg.name);
var description = 'API methods yet to be implemented are marked '
description += 'with a strikethrough.';

var sections = {
  server: 'Server',
  conf: 'Configuration',
  level: 'Log Level',
  admin: 'Administrators',
  db: 'Database',
  security: 'Security',
  session: 'Session',
  doc: 'Document',
}

var ignore = [
  'template',
  'tpl',
  'lint',
  'edit'
];

var rules = [], st = '~~';
rules.push({src: config.server.default, rep: qt.params.server});
rules.push({src: config.database.default, rep: qt.params.db});
rules.push({src: config.database.users, rep: qt.params.db});
rules.push({src: config.design.auth, rep: qt.params.ddoc});


rules.push({src: config.conf.section, rep: qt.params.section});
rules.push({src: config.conf.key, rep: qt.params.key});
rules.push({src: config.conf.value, rep: qt.params.value});

rules.push({src: config.admin.name, rep: qt.params.name});
rules.push({src: config.admin.pass, rep: qt.params.pass});

rules.push({src: /--file [^ ]+/, rep: '--file ' + qt.params.file});

rules.push({src: config.document.id, rep: qt.params.docid});
rules.push({src: /(-t|--template)/, rep: '$1 ' + qt.params.template});

function replace(str) {
  var i, rule, re;
  for(i = 0;i < rules.length;i++) {
    rule = rules[i];
    re = (rule.src instanceof RegExp)
      ? rule.src : new RegExp(rule.src, 'g');
    str = str.replace(re, rule.rep);
  }
  return str;
}

function tidy(u) {
  u = u.replace(/\.html/, '');
  u = u.replace(/_/g, '-');
  u = u.replace(/-{2,}/g, '-');
  u = u.replace(/-+$/, '');
  return u;
}

function order() {
  var out = [];
  var keys = Object.keys(sections), i, k, j, item, cmd;
  for(i = 0;i < keys.length;i++) {
    k = keys[i];
    section = sections[k];
    //if(!headers[k]) {
      out.push(sections[k] + DNL);
      //headers[k] = true;
    //}
    for(j = 0;j < qt.length;j++) {
      item = qt[j];
      cmd = item.cmd[0];
      if(~ignore.indexOf(cmd)) continue;
      if(k === 'server' && !sections[cmd]) {
        out.push(item);
      }else if(k === cmd && sections[cmd]) {
        out.push(item);
      }
    }
  }
  return out;
}

function build(qt) {
  var str = heading + DNL + description + DNL;
  var i, item, exe = pkg.name, nm, cmds, cmd, pre, post, disabled;
  for(i = 0;i < qt.length;i++) {
    item = qt[i];
    if(typeof item === 'string') {
      str += '## ' + item;
      continue;
    }
    pre = post = '';
    disabled = item.enabled === false;
    if(disabled) {
      pre = post = st;
    }
    //console.dir(item);
    cmds = item.cmd.slice(0);
    cmds.unshift(exe);
    nm = item.cmd[0];
    str += '### ' + pre + item.req + post + DNL;
    str += item.description + (disabled ? '.' : ':') + DNL;
    if(!disabled) {
      str += '```' + EOL + replace(cmds.join(' ')) + EOL + '```' + DNL;
    }
    str += 'Documentation: '
      + util.format('[%s](%s)', tidy(item.doc), item.url) + DNL;
  }
  return str;
}

process.stdout.write(build(order()));
process.exit(0);
