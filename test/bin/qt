#!/usr/bin/env node

var async = require('async');
var path = require('path');
var util = require('util');
var EOL = require('os').EOL;
var revert = require('ttycolor').defaults();
var base = path.normalize(path.join(__dirname, '..', '..'));
var nm = 'rlx';
var name = path.basename(process.argv[1]);
var exe = path.join(base, 'bin', nm);
var fixtures = require('../fixtures/qt');
var exec = require('child_process').exec;
var prefix = '[' + name + '] ';
var lines = [
  prefix + util.format('quick test started (tests: %s)', fixtures.length),
];

console.info(lines.join(EOL));

function run(fixtures, cb) {
  async.eachSeries(fixtures, function(test, callback) {
    function execute(callback) {
      var cmd = test.cmd.slice(0);
      if(test.enabled === false) {
        console.warn(prefix + 'not yet implemented %s', test.req);
        return callback(null, test, -1);
      }
      console.log(prefix + '%s %s', nm, cmd.join(' '));
      cmd.unshift(exe);
      cmd = cmd.join(' ');
      exec(cmd, function(err, stdout, stderr) {
        var code = err && err.code ? err.code : 0;
        if(err && !test.fails) {
          var e = new Error('quick test fixture failure');
          e.err = err;
          e.code = code;
          e.stdout = stdout || '';
          e.stderr = stderr || '';
          return callback(e, test, code);
        }
        callback(null, test, code);
      })
    }
    if(test.before) {
      return run(test.before, function(err) {
        var complete = !test.after ? callback : after;
        if(err) return complete(err);
        execute(complete);
      });
    }
    function after(err) {
      run(test.after, callback);
    }
    var complete = !test.after ? callback : after;
    execute(complete);
  }, function(err) {
    if(cb) return cb(err);
    if(err) {
      console.error(err.stderr.trim());
      process.exit(1);
    }
    console.info('[qt] ok');
    process.exit(0);
  })
}

run(fixtures);
